/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package org.jto.tabletool


import org.apache.tinkerpop.gremlin.process.traversal.P
import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversal
import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource
import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.`__`.*
import org.apache.tinkerpop.gremlin.structure.Graph
import org.apache.tinkerpop.gremlin.structure.Vertex
import org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerGraph
import kotlinx.cli.*
import org.jto.tabletool.ExcelTableLoader
import org.jto.tabletool.TableDataComparator
import org.slf4j.LoggerFactory
import java.io.FileOutputStream


fun <A> As(label: String?, vararg labels: String?): GraphTraversal<A, A> = start<A>().`as`(label, *labels)
fun <A> In(vararg labels: String?): GraphTraversal<A, Vertex> = start<A>().`in`(*labels)
fun <A> Is(predicate: P<A>): GraphTraversal<A, A> = start<A>().`is`(predicate)

enum class Function {
    ExtractDefsOnly,
    Compare
}

open class OutputHeaderColumn(
    val name: String,
    val alias: String? = name,
    val ignored: Boolean = false
)


fun main(args: Array<String>) {

    val logger = LoggerFactory.getLogger("Main")

    val parser = ArgParser("MFT definitions compare tool")

    val definitionInput by parser.option(ArgType.String, shortName = "d", description = "MFT Definition input file")
        .required()
    val function by parser.option(
        ArgType.Choice<Function>(), shortName = "f",
        description = "Function to be exectured"
    ).default(Function.Compare)
    val outputFile by parser.option(ArgType.String, shortName = "o", description = "Output file name").required()
    val dataFile by parser.option(
        ArgType.String,
        shortName = "c",
        description = "Compare with extracted definitions data file"
    )
    val outputColumns by parser.option(
        ArgType.String,
        shortName = "oc",
        description = "Column list which would be reported, in exact order, by default () "
    )
        .default(
            "id:Id:i;mftService:Service Name;mftType:ASI File Type;senderServer:Supplier Host;receiverServer:Receiver Host;senderServerGroup:Supplier HostGroup;receiverServerGroup:Receiver HostGroup;postScript:Postprocessing Command;" +
                    "postScriptParams:Postprocessing Arguments;receiverDirectory:Receiver Directory;senderUID:Supplier UID;receiverUID:Receiver UID;senderMandator:SUMAN;senderEnvironment:SURTE;receiverMandator:DEMAN;receiverEnvironment:DERTE;" +
                    "instance:Instance;validFrom:Valid From;validTo:Valid To;state:State"
        )

    parser.parse(args)

    val outputHeaderColumns =
        outputColumns.split(';').map {
            val parsedColumn = requireNotNull(
                "^(\\w+):([\\w\\s]+)(:(i))?$".toRegex().find(it)?.destructured
            ) { "The column $it in column list must follow the regexp ^(\\w+):([\\w\\s]+)(:(i))?\$" }
            OutputHeaderColumn(
                parsedColumn.component1(),
                parsedColumn.component2(),
                parsedColumn.component4().isNotBlank()
            )
        }

    val graph: Graph = TinkerGraph.open()
    val g: GraphTraversalSource = graph.traversal()

    //Load graph from excel
    ExcelGraphLoader(definitionInput, g).graphLoadTest()

    //Extract data out of graph (can be replaced by groovy to have configurable query)
    val definitionsTable =
        GraphQueryTableLoader(g).extractData().mapIndexed { rowIndex, row -> row + ("id" to "$rowIndex") }.toSet()


    when (function) {
        Function.Compare -> {
            val reqDataFile =
                requireNotNull(dataFile) { "The datafile (parameter c) must be given in order to compare records with that file" }
            //Load data from another excel file, for compare
            val extractTable = ExcelTableLoader(reqDataFile).graphLoadTest()
                .mapIndexed { rowIndex, row -> row + ("id" to "$rowIndex") }.toSet()

            val result = TableDataComparator(definitionsTable, extractTable, setOf("id")).compareTables()

            val workbook = StyledWorkbook()

            ComparatorResultExcelWriter(result, outputHeaderColumns, workbook).createCompareResultSheet()
            TableExcelWriter(
                definitionsTable,
                outputHeaderColumns,
                workbook,
                "mftDefinitions"
            ).createDefinitionsSheet()
            TableExcelWriter(extractTable, outputHeaderColumns, workbook, "mftExtract").createDefinitionsSheet()

            logger.info("Writing compare result into excel: $outputFile")
            workbook.write(FileOutputStream(outputFile))
        }

        Function.ExtractDefsOnly -> {
            val workbook = StyledWorkbook()

            TableExcelWriter(
                definitionsTable,
                outputHeaderColumns,
                workbook,
                "mftDefinitions"
            ).createDefinitionsSheet()

            workbook.write(FileOutputStream(outputFile))
        }
    }
}






